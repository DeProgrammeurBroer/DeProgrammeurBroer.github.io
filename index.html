<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>De Oude Herberg</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script> <!-- Voor icons -->
    <style>
        /* --- SFEER & BASIS --- */
        body {
            font-family: 'Crimson Text', serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1, h2, h3, .tavern-font { font-family: 'Cinzel', serif; }

        .background-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; object-fit: cover;
        }

        .main-scroll-container {
            width: 100%; height: 100%;
            overflow-y: auto;
            position: relative; z-index: 10;
            display: flex; flex-direction: column; align-items: center;
            padding: 20px;
        }

        /* --- PERKAMENT STIJLEN --- */
        .parchment-box {
            background-color: #f4e4bc;
            background-image: url("https://www.transparenttextures.com/patterns/aged-paper.png");
            box-shadow: 0 4px 20px rgba(0,0,0,0.6), inset 0 0 60px rgba(160, 82, 45, 0.2);
            border-radius: 4px;
            border: 2px solid #d7c496;
            position: relative;
            display: flex; flex-direction: column;
        }

        /* --- TITEL --- */
        .main-title {
            font-size: 4rem; color: #f4e4bc;
            text-shadow: 4px 4px 0px #3e2723, 0 0 20px rgba(0,0,0,0.8);
            margin: 1rem 0 2rem 0; font-weight: 700; text-align: center;
        }

        /* --- KNOPPEN --- */
        .tavern-btn {
            background: #5d4037; color: #f4e4bc;
            border: 2px solid #3e2723;
            transition: all 0.2s ease; cursor: pointer;
            text-decoration: none; display: flex; align-items: center; justify-content: center; gap: 8px;
            font-weight: bold;
        }
        .tavern-btn:hover {
            background: #795548; transform: scale(1.02); color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .tavern-btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .btn-small { padding: 4px 12px; font-size: 0.9rem; }

        /* --- LAYOUT GRID (3 Kolommen) --- */
        .tavern-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            width: 100%; max-width: 1400px;
            align-items: start; /* Belangrijk zodat ze niet uitrekken */
        }

        /* --- CHAT (LINKS) --- */
        .chat-area { height: 500px; }
        .chat-messages {
            flex-grow: 1; overflow-y: auto; padding: 10px;
            background: rgba(255,255,255,0.4); border: 1px solid rgba(62,39,35,0.2);
            margin-bottom: 10px; border-radius: 4px;
        }
        .chat-input {
            background: rgba(255,255,255,0.7); border: 2px solid #5d4037;
            padding: 8px; border-radius: 4px; width: 100%;
        }

        /* --- MENU (MIDDEN) --- */
        .menu-area { padding: 2rem; }

        /* --- SPELLEN (RECHTS) --- */
        .games-area { height: 500px; }
        .games-list {
            flex-grow: 1; overflow-y: auto;
            background: rgba(62,39,35,0.05); padding: 10px;
            border-radius: 4px; margin-bottom: 10px;
        }
        .game-card {
            background: rgba(255,255,255,0.6); padding: 10px; margin-bottom: 8px;
            border: 1px dashed #5d4037; border-radius: 4px;
            display: flex; justify-content: space-between; align-items: center;
        }

        /* --- GAME OVERLAY (MODAL) --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: none; align-items: center; justify-content: center;
        }
        .modal-content {
            background: #f4e4bc; padding: 20px; border-radius: 8px;
            max-width: 600px; width: 95%; max-height: 90vh; overflow-y: auto;
            border: 4px solid #5d4037; text-align: center;
        }
        
        /* Kaartstijl */
        .card-button {
            width: 50px; height: 70px; 
            border: 1px solid #3e2723;
            border-radius: 4px;
            padding: 2px;
            text-align: center;
            line-height: 1.2;
            font-size: 1.2em;
        }
        .card-button:hover {
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .card-red { color: red; }
        .card-black { color: black; }


        /* --- BARMAN MODAL STIJL (NIEUW) --- */
        #barman-modal {
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(5px);
            display: none;
            flex-direction: column;
            justify-content: flex-end; /* Barman staat onderaan */
            align-items: center; /* Lijn horizontaal in het midden uit */
            padding-bottom: 0; 
            padding-right: 0; 
            z-index: 110; 
        }

        .barman-cutout {
            width: 400px; /* Maak de barman groter */
            height: auto;
            position: relative;
            margin-bottom: 0;
            transform: translateY(15%); /* Duw 15% naar beneden buiten beeld */
            z-index: 101;
        }
        .barman-cutout img {
            width: 100%;
            object-fit: contain;
            /* Gebruik barman.png als lokale cutout (NIEUW) */
            content: url('barman.png'); 
        }

        .speech-bubble {
            background: #ffffff;
            border-radius: 1rem;
            padding: 1.5rem;
            position: relative;
            max-width: 400px;
            min-width: 300px;
            /* AANGEPAST: Minder negatieve marge op PC om de wolk 10% omhoog te brengen */
            margin-bottom: -75px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            text-align: left;
            border: 2px solid #5d4037;
            align-self: center; /* Centreer de wolk boven de barman */
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%; /* Centreer de pijl onder de wolk */
            width: 0;
            height: 0;
            border: 10px solid transparent;
            border-top-color: #ffffff;
            border-bottom: 0;
            margin-left: -10px; /* Herstel margin voor centrering */
        }


        /* Responsive */
        @media (max-width: 1000px) {
            .tavern-grid { grid-template-columns: 1fr; max-width: 600px; }
            .main-title { font-size: 2.5rem; }
            /* Volgorde voor mobiel: Menu eerst, dan Spellen, dan Chat */
            .area-menu { order: 1; }
            .area-games { order: 2; }
            .area-chat { order: 3; }
            .barman-cutout { width: 300px; } /* Behoud een redelijke grootte op mobiel */
            .speech-bubble { max-width: 90%; margin-bottom: 20px; } /* Terug naar normale, positieve marge op mobiel */
        }
    </style>
</head>
<body>

    <!-- BARMAN WELKOM MODAL (NIEUW) -->
    <div id="barman-modal" class="modal-overlay" style="display: none;">
        <div class="speech-bubble">
            <p class="text-xl font-bold text-amber-900 mb-4 tavern-font">Welkom in De Oude Herberg!</p>
            <p class="text-gray-700 mb-4">Ga zitten, reiziger. Wat is jouw naam?</p>
            <form id="name-form" class="flex flex-col gap-3">
                <input type="text" id="visitor-name-input" class="p-2 border-2 border-amber-900 rounded" placeholder="Typ hier uw naam" required maxlength="20">
                <button type="submit" class="tavern-btn rounded py-2">Binnenkomen</button>
            </form>
        </div>
        <div class="barman-cutout">
            <!-- Gebruik barman.png, met een placeholder als fallback -->
            <img src="barman.png" alt="Herberg Barman" onerror="this.onerror=null; this.src='https://placehold.co/300x500/2c1810/f4e4bc?text=Barman+Cutout'">
        </div>
    </div>


    <!-- AMBIENT MUSIC (Muziek start automatisch en herhaalt) -->
    <audio id="ambient-music" src="muziek.mp3" autoplay loop></audio>

    <!-- BACKGROUND -->
    <img src="tavern.png" class="background-layer" alt="Tavern Background" onerror="this.style.background='#2c1810'">

    <div class="main-scroll-container">
        <h1 class="main-title">De Oude Herberg</h1>

        <!-- 3-KOLOMMEN GRID -->
        <div class="tavern-grid">

            <!-- KOLOM 1: CHAT (Links op desktop, onderaan op mobiel) -->
            <div class="parchment-box area-chat chat-area p-4">
                <h2 class="text-2xl tavern-font text-amber-900 mb-2 border-b border-amber-900/30">Gesprekken</h2>
                <div id="chat-messages" class="chat-messages text-left text-sm">
                    <div class="text-center italic text-amber-900/50 mt-4">Laden...</div>
                </div>
                <form id="chat-form" class="flex gap-2">
                    <input type="text" id="message-input" class="chat-input" placeholder="Zeg iets..." autocomplete="off">
                    <button type="submit" class="tavern-btn px-4 rounded">></button>
                </form>
                <div id="user-status" class="text-xs text-amber-900/60 mt-1 text-center">...</div>
            </div>

            <!-- KOLOM 2: MENU (Midden) -->
            <div class="parchment-box area-menu menu-area text-center">
                <h2 class="text-3xl tavern-font text-amber-900 mb-6 border-b-2 border-amber-900/20 pb-2">Menu</h2>
                <div class="space-y-4">
                    <a href="kaas.html" class="tavern-btn w-full py-4 text-xl"><span>üßÄ</span> Ik zie ik zie...</a>
                    <a href="jungle.html" class="tavern-btn w-full py-4 text-xl"><span>ü¶Å</span> Raad het dier</a>
                    <div class="py-2 text-amber-900/40 text-sm border-t border-dashed border-amber-900/20 mt-4">
                        Meer spellen in de maak...
                    </div>
                </div>
            </div>

            <!-- KOLOM 3: MULTIPLAYER SPELLEN (Rechts) -->
            <div class="parchment-box area-games games-area p-4">
                <h2 class="text-2xl tavern-font text-amber-900 mb-2 border-b border-amber-900/30 flex justify-between items-center">
                    <span>Herberg Spellen</span>
                    <span class="text-xs bg-amber-900 text-white px-2 py-0.5 rounded-full">Online</span>
                </h2>
                
                <!-- Knoppen om spellen te maken -->
                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button onclick="hostGame('tictactoe')" class="tavern-btn btn-small rounded py-2">‚ùå‚≠ï Boter Kaas</button>
                    <button onclick="hostGame('hangman')" class="tavern-btn btn-small rounded py-2">üî§ Galgje</button>
                    <!-- NIEUW: PESTEN -->
                    <button onclick="hostGame('pesten')" class="tavern-btn btn-small rounded py-2">üÉè Pesten</button>
                    <!-- NIEUW: DOBBELEN -->
                    <button onclick="hostGame('dice')" class="tavern-btn btn-small rounded py-2">üé≤ Dobbelen</button>
                </div>

                <h3 class="text-sm font-bold text-amber-800 mb-1 uppercase tracking-wide">Open Tafels:</h3>
                <div id="games-list" class="games-list">
                    <div class="text-center italic text-amber-900/50 mt-4">Geen open spellen.<br>Start er een!</div>
                </div>
            </div>

        </div>
    </div>

    <!-- GAME MODAL (Overlay) -->
    <div id="game-modal" class="modal-overlay">
        <div class="modal-content relative">
            <!-- AANGEPAST: userQuitGame roept nu de verwijder-logica aan -->
            <button onclick="userQuitGame()" class="absolute top-2 right-2 text-red-800 font-bold hover:text-red-600 border border-red-800 rounded px-2 bg-red-100">‚úñ Verlaten</button>
            <div id="game-stage">
                <!-- Dynamische Game Content komt hier -->
            </div>
        </div>
    </div>

    <!-- FIREBASE LOGIC -->
    <!-- Alle logica is nu in √©√©n blok geplaatst om module-volgorde problemen op te lossen -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, onSnapshot, query, serverTimestamp, orderBy, updateDoc, doc, deleteDoc, setDoc, getDoc } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // 1. CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyBrJytboOjIzpTFHDLBrDlDrF8vIkJyqJ4",
            authDomain: "manonopeenrij.firebaseapp.com",
            projectId: "manonopeenrij",
            storageBucket: "manonopeenrij.firebasestorage.app",
            messagingSenderId: "575065794428",
            appId: "1:575065794428:web:78a68f77a426f7daf3e6f9",
            measurementId: "G-ERGHXY3LR7"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // Globals
        let currentUser = null;
        let myUsername = localStorage.getItem('tavern_username');
        let activeGameListener = null;
        let currentGameId = null;

        // --- AUTHENTICATIE & START FUNCTIES ---

        const initAuth = async () => {
            if (!myUsername) return;
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try { 
                        await signInWithCustomToken(auth, __initial_auth_token); 
                        return; 
                    } catch(e){
                        // Token mismatch, val terug op anonieme login
                    }
                }
                await signInAnonymously(auth);
            } catch (err) { console.error("Auth failed", err); }
        };

        const startTavern = () => {
            // Pas de globale myUsername aan als de naam is ingevoerd
            myUsername = localStorage.getItem('tavern_username'); 
            if (myUsername) {
                // Verberg de barman, toon de UI
                document.getElementById('barman-modal').style.display = 'none';
                initAuth(); // Start inloggen
            }
        };


        // --- EERSTE BEZOEKER FLOW ---

        // Event listener voor het Naam-formulier
        document.getElementById('name-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const inputElement = document.getElementById('visitor-name-input');
            const name = inputElement.value.trim().substring(0, 20); 
            if (name) {
                localStorage.setItem('tavern_username', name);
                startTavern(); // Start de herberg
            }
        });

        // Controleer bij het laden of de naam al bekend is
        if (!myUsername) {
            document.getElementById('barman-modal').style.display = 'flex';
        } else {
            startTavern();
        }

        // --- AUTH STATE CHANGE (Wordt alleen getriggerd na initAuth) ---
        onAuthStateChanged(auth, (user) => {
            if(user) {
                currentUser = user;
                document.getElementById('user-status').innerText = `Ingelogd als: ${myUsername}`; 
                setupChat();
                setupGamesList();
            } else {
                // Optioneel: toon een "niet ingelogd" status
                document.getElementById('user-status').innerText = `Status: Verbinding verbroken`; 
            }
        });


        // --- CHAT LOGIC ---

        function setupChat() {
            const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'chat'));
            onSnapshot(q, (snap) => {
                const msgs = [];
                snap.forEach(d => msgs.push({id: d.id, ...d.data()}));
                msgs.sort((a,b) => (a.timestamp?.seconds||0) - (b.timestamp?.seconds||0));
                
                const html = msgs.map(m => `
                    <div class="mb-1 border-b border-amber-900/10 pb-1">
                        <span class="font-bold text-amber-900">${m.author}:</span>
                        <span class="text-amber-800">${escape(m.text)}</span>
                    </div>`).join('');
                const el = document.getElementById('chat-messages');
                el.innerHTML = html || '<div class="text-center italic opacity-50">Stil...</div>';
                el.scrollTop = el.scrollHeight;
            });
        }

        document.getElementById('chat-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const inp = document.getElementById('message-input');
            if(inp.value.trim() && currentUser) {
                addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'chat'), {
                    text: inp.value.trim(),
                    author: myUsername,
                    uid: currentUser.uid,
                    timestamp: serverTimestamp()
                });
                inp.value = '';
            }
        });


        // --- GAME UTILITIES ---
        
        window.isMyGame = function(g) {
            if(!currentUser) return false;
            return g.hostUid === currentUser.uid || g.guestUid === currentUser.uid;
        };
        
        function initializeDeck() {
            // Pesten uses 32 cards (7 through Ace) + 2 Jokers for simplicity
            const suits = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
            const ranks = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2']; 
            let deck = [];
            for (const suit of suits) {
                for (const rank of ranks) { deck.push(rank + suit); }
            }
            deck.push('Joker', 'Joker'); 
            
            // Shuffle the deck (Fisher-Yates)
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function removeCard(hand, cardToRemove) {
            const index = hand.indexOf(cardToRemove);
            if (index > -1) {
                hand.splice(index, 1);
                return true;
            }
            return false;
        }

        /**
         * Hulpfunctie om rang en soort uit een kaartstring te halen
         * @param {string} card
         * @returns {{rank: string, suit: string|null}}
         */
        function getCardParts(card) {
            if (card === 'Joker') return { rank: 'Joker', suit: null };
            const rank = card.slice(0, -1);
            const suit = card.slice(-1);
            return { rank, suit };
        }

        function getInitialState(type) {
            if(type === 'tictactoe') return { board: Array(9).fill(''), turn: 'X', winner: null };
            // Max mistakes is 12
            if(type === 'hangman') return { word: '', guesses: [], mistakes: 0, maxMistakes: 12, setter: 'host', phase: 'setup' }; 
            
            if(type === 'pesten') return { 
                turn: 'host', // Placeholder, wordt gerandomiseerd bij start
                deck: [], 
                hostHand: [], 
                guestHand: [], 
                discardPile: [],
                status: 'waiting_start' 
            };
            
            if(type === 'dice') return { 
                turn: 'host', 
                hostRoll: null, 
                guestRoll: null, 
                winner: null,
                message: 'Host begint.'
            };

            return {};
        }
        
        // --- GAME LOBBY LOGIC ---

        function setupGamesList() {
            const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'games'));
            onSnapshot(q, (snap) => {
                const listEl = document.getElementById('games-list');
                const games = [];
                snap.forEach(d => games.push({id: d.id, ...d.data()}));
                
                const activeGames = games.filter(g => g.status === 'waiting' || (g.status === 'playing' && window.isMyGame(g)));
                
                if(activeGames.length === 0) {
                    listEl.innerHTML = '<div class="text-center italic text-amber-900/50 mt-4">Geen open spellen.</div>';
                    return;
                }

                listEl.innerHTML = activeGames.map(g => {
                    const isMine = g.hostUid === currentUser.uid;
                    let icon;
                    if (g.type === 'tictactoe') icon = '‚ùå‚≠ï';
                    else if (g.type === 'hangman') icon = 'üî§';
                    else if (g.type === 'pesten') icon = 'üÉè';
                    else if (g.type === 'dice') icon = 'üé≤';
                    else icon = '‚ùì';

                    const gameName = g.type === 'tictactoe' ? 'Boter Kaas' : g.type === 'hangman' ? 'Galgje' : g.type === 'pesten' ? 'Pesten' : g.type === 'dice' ? 'Dobbelen' : 'Spel';
                    
                    const btnText = isMine ? 'Wachten...' : 'Meespelen';
                    const btnClass = isMine ? 'opacity-50 cursor-default' : 'hover:bg-amber-700';
                    const action = isMine ? '' : `onclick="joinGame('${g.id}')"`;
                    
                    if(g.status === 'playing' && (g.hostUid === currentUser.uid || g.guestUid === currentUser.uid)) {
                        return `<div class="game-card">
                            <span>${icon} vs ${g.host}</span>
                            <button onclick="rejoinGame('${g.id}', '${g.type}')" class="tavern-btn btn-small rounded bg-green-700">Hervatten</button>
                        </div>`;
                    }

                    return `
                    <div class="game-card">
                        <div class="flex flex-col">
                            <span class="font-bold text-sm text-amber-900">${icon} ${gameName}</span>
                            <span class="text-xs text-amber-900/60">Host: ${g.host}</span>
                        </div>
                        <button ${action} class="tavern-btn btn-small rounded ${btnClass}">${btnText}</button>
                    </div>`;
                }).join('');
            });
        }

        window.hostGame = async (type) => {
            if(!currentUser) return alert("Even geduld, verbinden...");
            
            const gameData = {
                type: type,
                host: myUsername,
                hostUid: currentUser.uid,
                status: 'waiting', 
                timestamp: serverTimestamp(),
                state: getInitialState(type)
            };

            const docRef = await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'games'), gameData);
            openGameUI(docRef.id, type, 'host');
        };

        window.joinGame = async (gameId) => {
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            await updateDoc(gameRef, {
                guestUid: currentUser.uid,
                guest: myUsername,
                status: 'playing'
            });
             openGameUI(gameId, null, 'guest'); 
        };

        window.rejoinGame = (id, type) => openGameUI(id, type, 'player');


        // --- GAME PLAY UI & ACTIONS ---

        window.userQuitGame = async () => {
            if(currentGameId) {
                try {
                    await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', currentGameId));
                } catch(e) { console.log("Game al weg of error", e); e.printStackTrace(); }
            }
            closeGameModal();
        };

        window.closeGameModal = () => {
            document.getElementById('game-modal').style.display = 'none';
            if(activeGameListener) activeGameListener(); 
            activeGameListener = null;
            currentGameId = null;
        };

        function openGameUI(gameId, typeHint, role) {
            currentGameId = gameId;
            const modal = document.getElementById('game-modal');
            const stage = document.getElementById('game-stage');
            modal.style.display = 'flex';
            stage.innerHTML = '<div class="text-2xl animate-pulse">Spel laden...</div>';

            activeGameListener = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), (docSnap) => {
                if(!docSnap.exists()) {
                    stage.innerHTML = "<div class='text-red-800 font-bold text-xl'>Tafel is gesloten.</div>";
                    setTimeout(closeGameModal, 2000);
                    return;
                }
                const game = docSnap.data();
                renderGame(game, docSnap.id);
            });
        }

        function renderGame(game, id) {
            const stage = document.getElementById('game-stage');
            const amIHost = game.hostUid === currentUser.uid;
            
            let gameTitle = game.type === 'tictactoe' ? 'Boter, Kaas & Eieren' : game.type === 'hangman' ? 'Galgje' : game.type === 'pesten' ? 'Pesten' : 'Dobbelen';
            let html = `<h2 class="text-3xl tavern-font mb-4 text-amber-900">${gameTitle}</h2>`;
            html += `<div class="mb-4 text-amber-800">Spelers: <b>${game.host}</b> vs <b>${game.guest || 'Wachten...'}</b></div>`;

            if(game.status === 'waiting') {
                html += `<div class="p-8 border-2 border-dashed border-amber-900/30 rounded bg-amber-50">
                    <p class="animate-pulse">Wachten op tegenstander...</p>
                    <p class="text-sm mt-2">De code ligt op tafel, wie durft?</p>
                </div>`;
                stage.innerHTML = html;
                return;
            }

            // --- TICTACTOE RENDER ---
            if(game.type === 'tictactoe') {
                const board = game.state.board;
                const mySymbol = amIHost ? 'X' : 'O';
                const isMyTurn = game.state.turn === mySymbol;
                const winner = game.state.winner;

                let statusText = isMyTurn ? "Jouw beurt!" : `Wachten op ${amIHost ? game.guest : game.host}...`;
                if(winner) statusText = winner === 'DRAW' ? "Gelijkspel!" : (winner === mySymbol ? "Je hebt gewonnen! üéâ" : "Helaas, verloren.");

                html += `<div class="text-xl font-bold mb-4 ${isMyTurn ? 'text-green-700' : 'text-amber-900'}">${statusText}</div>`;
                
                html += `<div class="grid grid-cols-3 gap-2 w-64 mx-auto mb-4">`;
                board.forEach((cell, idx) => {
                    html += `<div onclick="tttMove('${id}', ${idx}, '${mySymbol}', ${isMyTurn && !winner})" 
                        class="w-20 h-20 bg-amber-100 border-2 border-amber-900 flex items-center justify-center text-4xl cursor-pointer hover:bg-amber-200">
                        ${cell}
                    </div>`;
                });
                html += `</div>`;
                if(winner) html += `<button onclick="userQuitGame()" class="tavern-btn px-6 py-2 mx-auto mt-4 rounded">Sluit Spel</button>`;
            } 

            // --- HANGMAN RENDER ---
            else if(game.type === 'hangman') {
                const state = game.state;
                const isSetter = (state.setter === 'host' && amIHost) || (state.setter === 'guest' && !amIHost);
                
                if(state.phase === 'setup') {
                    if(isSetter) {
                        html += `<div class="flex flex-col gap-2">
                            <p>Kies een woord voor je tegenstander:</p>
                            <input type="text" id="hangman-word" class="p-2 border border-amber-900 rounded uppercase text-center" maxlength="10">
                            <button onclick="hangmanSetWord('${id}')" class="tavern-btn px-4 py-2 rounded">Bevestig Woord</button>
                        </div>`;
                    } else {
                        html += `<p class="animate-pulse">Tegenstander bedenkt een woord...</p>`;
                    }
                } else {
                    const wordDisplay = state.word.split('').map(l => state.guesses.includes(l) ? l : '_').join(' ');
                    const won = !wordDisplay.includes('_');
                    const lost = state.mistakes >= state.maxMistakes;
                    
                    html += `<div class="text-4xl font-mono tracking-widest mb-6">${wordDisplay}</div>`;
                    html += `<div class="text-red-700 font-bold mb-4">Fouten: ${state.mistakes} / ${state.maxMistakes}</div>`;

                    if(won || lost) {
                         const msg = won ? (isSetter ? "Ze hebben het geraden!" : "Je hebt gewonnen!") : (isSetter ? "Ze zijn opgehangen! Jij wint." : `Verloren! Het woord was ${state.word}`);
                         html += `<div class="text-2xl font-bold mb-4">${msg}</div>`;
                         html += `<button onclick="userQuitGame()" class="tavern-btn px-6 py-2 mx-auto rounded">Sluit Spel</button>`;
                    } else if (!isSetter) {
                        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
                        html += `<div class="flex flex-wrap gap-1 justify-center max-w-md mx-auto">`;
                        alphabet.forEach(letter => {
                            const used = state.guesses.includes(letter);
                            html += `<button onclick="hangmanGuess('${id}', '${letter}')" 
                                ${used ? 'disabled' : ''} 
                                class="w-8 h-8 border border-amber-900 rounded ${used ? 'bg-amber-900/20' : 'bg-amber-100 hover:bg-white'}">
                                ${letter}
                            </button>`;
                        });
                        html += `</div>`;
                    } else {
                        html += `<p>Je tegenstander is aan het raden...</p>`;
                    }
                }
            }
            
            // --- PESTEN RENDER ---
            else if(game.type === 'pesten') {
                const state = game.state;
                const myRole = amIHost ? 'host' : 'guest';
                const opponentRole = amIHost ? 'guest' : 'host';
                const isMyTurn = state.turn === myRole;
                const myHand = state[myRole + 'Hand'];
                const opponentHandSize = state[opponentRole + 'Hand'] ? state[opponentRole + 'Hand'].length : 0;
                const topCard = state.discardPile.length > 0 ? state.discardPile[state.discardPile.length - 1] : 'Geen';
                
                // Haal de rang en soort van de bovenste kaart op met helper
                const { rank: topRank, suit: topSuit } = getCardParts(topCard);

                if (state.status === 'waiting_start') {
                    html += `<p class="mb-4">Wachten op een tegenstander om te starten...</p>`;
                    if (amIHost) {
                        html += `<button onclick="pestenStartGame('${id}')" ${game.guest ? '' : 'disabled'} class="tavern-btn px-6 py-2 rounded mt-2">Start Spel & Deel Kaarten</button>`;
                    } else {
                        html += `<p class="animate-pulse text-sm mt-2">Wachten op de host (${game.host}) om te starten.</p>`;
                    }
                } else if (state.status === 'finished') {
                    html += `<div class="text-2xl font-bold text-red-700 mt-4">${state.winner === myRole ? "Je hebt gewonnen!" : `Je hebt verloren. Winnaar: ${game[state.winner]}`}</div>`;
                    html += `<button onclick="userQuitGame()" class="tavern-btn px-6 py-2 mx-auto mt-4 rounded">Sluit Spel</button>`;
                } else {
                    let statusText = isMyTurn ? "Jouw beurt! Speel of pak een kaart." : `Wachten op ${game[state.turn]}...`;
                    
                    html += `<div class="text-xl font-bold mb-4 ${isMyTurn ? 'text-green-700' : 'text-amber-900'}">${statusText}</div>`;
                    html += `<div class="flex justify-around items-center mb-4 text-center border-b pb-4 border-amber-900/20">
                        <div><span class="text-sm text-amber-800">${game[opponentRole]}</span><br>üÉè x ${opponentHandSize}</div>
                        <div>
                            <span class="text-xs text-amber-800">Bovenste Kaart:</span><br>
                            <span class="text-3xl font-bold ${topSuit === '‚ô•' || topSuit === '‚ô¶' ? 'card-red' : 'card-black'}">${topCard}</span>
                        </div>
                        <div><span class="text-sm text-amber-800">Deck:</span><br>üì¶ x ${state.deck.length}</div>
                    </div>`;
                    
                    // My Hand
                    html += `<h3 class="font-bold mb-2">Jouw Kaarten:</h3>`;
                    html += `<div class="flex flex-wrap justify-center gap-2 mb-4">`;
                    myHand.forEach((card, index) => {
                         const { rank: cardRank, suit: cardSuit } = getCardParts(card);
                         
                         // Check speelbaarheid (zelfde logica als in pestenPlayCard)
                         const isJoker = cardRank === 'Joker';
                         const isTwo = cardRank === '2';
                         let canPlay = isJoker || isTwo; 
                         
                         if (!canPlay && topCard !== 'Geen') {
                             if (topRank === 'Joker') {
                                 // Na een Joker mag je elke kaart spelen (vereenvoudigd)
                                 canPlay = true; 
                             } else {
                                 // Check rang of soort match
                                 canPlay = (cardRank === topRank) || (cardSuit === topSuit);
                             }
                         }

                         const colorClass = cardSuit === '‚ô•' || cardSuit === '‚ô¶' ? 'card-red' : 'card-black';
                         const enabledClass = isMyTurn && canPlay ? 'bg-white hover:bg-green-100 cursor-pointer' : 'bg-gray-300 opacity-70 cursor-not-allowed';

                         html += `<button 
                            onclick="pestenPlayCard('${id}', '${card}', ${index})" 
                            ${!(isMyTurn && canPlay) ? 'disabled' : ''}
                            class="card-button ${colorClass} ${enabledClass}">
                            ${card}
                        </button>`;
                    });
                    html += `</div>`;
                    
                    // Draw Button
                    html += `<button onclick="pestenDrawCard('${id}')" ${!isMyTurn ? 'disabled' : ''} class="tavern-btn px-6 py-2 rounded mt-2">
                        ${isMyTurn ? `Pak een kaart (Deck: ${state.deck.length})` : 'Wachten...'}
                    </button>`;
                }
            }

            // --- DOBBELEN RENDER ---
            else if(game.type === 'dice') {
                const state = game.state;
                const myRole = amIHost ? 'host' : 'guest';
                const isMyTurn = state.turn === myRole;
                
                let statusText = state.message;
                if (!state.winner && !state.hostRoll && !state.guestRoll) {
                    statusText = isMyTurn ? "Tijd om te dobbelen!" : `Wachten op ${game[state.turn]} om te gooien...`;
                }

                html += `<div class="text-xl font-bold mb-4 text-amber-900">${statusText}</div>`;
                
                // Dice Display
                html += `<div class="flex justify-around items-center my-6">
                    <div class="text-center">
                        <h3 class="font-bold text-amber-800">${game.host}</h3>
                        <div class="text-6xl p-4 border border-amber-900/50 rounded inline-block bg-amber-100">${state.hostRoll !== null ? state.hostRoll : '?'}</div>
                    </div>
                    <div class="text-center">
                        <h3 class="font-bold text-amber-800">${game.guest || 'Tegenstander'}</h3>
                        <div class="text-6xl p-4 border border-amber-900/50 rounded inline-block bg-amber-100">${state.guestRoll !== null ? state.guestRoll : '?'}</div>
                    </div>
                </div>`;

                if (state.winner) {
                    html += `<button onclick="diceNewRound('${id}')" class="tavern-btn px-6 py-2 mx-auto mt-4 rounded">Nieuwe Ronde</button>`;
                    html += `<button onclick="userQuitGame()" class="tavern-btn px-6 py-2 mx-auto mt-4 rounded bg-red-700">Sluit Spel</button>`;
                } else if (isMyTurn) {
                    html += `<button onclick="diceRoll('${id}')" class="tavern-btn px-8 py-3 rounded text-xl animate-pulse">Gooi de Dobbelsteen! üé≤</button>`;
                } else {
                    html += `<p class="italic text-sm">Wachten...</p>`;
                }
            }

            stage.innerHTML = html;
        }

        // --- GAME ACTIONS IMPLEMENTATIES ---
        
        window.tttMove = async (id, idx, symbol, allowed) => {
            if(!allowed) return;
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if(!snap.exists()) return;
            const data = snap.data();
            const state = data.state;
            
            if(state.board[idx] !== '') return; 
            
            state.board[idx] = symbol;
            state.turn = symbol === 'X' ? 'O' : 'X';
            
            const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
            if(wins.some(c => state.board[c[0]] && state.board[c[0]] === state.board[c[1]] && state.board[c[0]] === state.board[c[2]])) {
                state.winner = symbol;
            } else if(!state.board.includes('')) {
                state.winner = 'DRAW';
            }
            
            await updateDoc(ref, { state: state });
        };

        window.hangmanSetWord = async (id) => {
            const word = document.getElementById('hangman-word').value.toUpperCase().trim();
            if(word.length < 2) return alert("Te kort!");
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            await updateDoc(gameRef, {
                'state.word': word,
                'state.phase': 'guessing'
            });
        };

        window.hangmanGuess = async (id, letter) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if(!snap.exists()) return;
            const data = snap.data();
            const state = data.state;

            if(state.guesses.includes(letter)) return;
            state.guesses.push(letter);
            
            if(!state.word.includes(letter)) {
                state.mistakes++;
            }
            
            await updateDoc(ref, { state: state });
        };
        
        window.pestenStartGame = async (id) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists() || !snap.data().guest) return;
            let data = snap.data();
            let state = data.state;
            
            if (state.status !== 'waiting_start') return;

            let fullDeck = initializeDeck(); 
            if (fullDeck.length < 15) { 
                console.error("Deck te klein of niet geladen.");
                return;
            }
            
            state.deck = fullDeck;
            state.hostHand = state.deck.splice(0, 7);
            state.guestHand = state.deck.splice(0, 7);

            let firstCard = state.deck.splice(0, 1)[0];

            // FIX: Zorg dat de eerste kaart geen speciale kaart (2 of Joker) is
            while (firstCard === 'Joker' || firstCard.includes('2')) {
                state.deck.push(firstCard); // Speciale kaart terug in de pot
                // Shuffle the deck again (simpele herschikking)
                for (let i = state.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [state.deck[i], state.deck[j]] = [state.deck[j], state.deck[i]];
                }
                firstCard = state.deck.splice(0, 1)[0]; // Trek nieuwe kaart
            }

            state.discardPile.push(firstCard);
            
            // FIX: Randomiseer de startspeler
            state.turn = Math.random() < 0.5 ? 'host' : 'guest'; 
            state.status = 'playing';

            await updateDoc(ref, { state: state });
        };

        window.pestenPlayCard = async (id, card, index) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;
            const data = snap.data();
            let state = data.state; 
            
            const myRole = data.hostUid === currentUser.uid ? 'host' : 'guest';
            const opponentRole = myRole === 'host' ? 'guest' : 'host';

            if (state.turn !== myRole || state.status !== 'playing') return;

            const topCard = state.discardPile[state.discardPile.length - 1];
            
            // Gebruik de helper functie om rang en soort op te halen
            const { rank: cardRank, suit: cardSuit } = getCardParts(card);
            const { rank: topRank, suit: topSuit } = getCardParts(topCard);

            // FIX: Verbeterde speelvalidatie
            const isJoker = cardRank === 'Joker';
            const isTwo = cardRank === '2';
            let canPlay = isJoker || isTwo; // Joker en 2 zijn altijd speelbaar

            if (!canPlay) {
                if (topRank === 'Joker') {
                    // Als de bovenste kaart een Joker is, mag elke niet-speciale kaart gespeeld worden
                    canPlay = true; 
                } else {
                    // Check rang of soort match
                    canPlay = (cardRank === topRank) || (cardSuit === topSuit);
                }
            }

            if (!canPlay) { return; } 

            // Kaart is geldig: speel de kaart
            state.discardPile.push(card);
            removeCard(state[myRole + 'Hand'], card);
            
            let nextTurn = opponentRole;

            // Hier komt de logica voor de speciale kaarten (bijv. 2, Joker, etc.)
            // Nu alleen beurtwisseling (geen actie-effecten in deze simpele versie)
            
            // WINNAAR CHECK
            if (state[myRole + 'Hand'].length === 0) {
                state.winner = myRole;
                state.status = 'finished';
                nextTurn = null; 
            } 
            
            // BEURT WISSELEN
            if (nextTurn) {
                state.turn = nextTurn;
            }

            await updateDoc(ref, { state: state });
        };

        window.pestenDrawCard = async (id) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;
            const data = snap.data();
            let state = data.state; 
            
            const myRole = data.hostUid === currentUser.uid ? 'host' : 'guest';
            const opponentRole = myRole === 'host' ? 'guest' : 'host';

            if (state.turn !== myRole || state.status !== 'playing') return;
            if (state.deck.length === 0) return;

            // Pak 1 kaart
            const drawnCard = state.deck.splice(0, 1)[0];
            state[myRole + 'Hand'].push(drawnCard);

            // Geef de beurt door na het pakken
            state.turn = opponentRole;

            await updateDoc(ref, { state: state });
        };

        window.diceRoll = async (id) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;
            const data = snap.data();
            const state = data.state;
            
            const myRole = data.hostUid === currentUser.uid ? 'host' : 'guest';
            const opponentRole = myRole === 'host' ? 'guest' : 'host';
            
            if (state.turn !== myRole || state.winner) return;

            const roll = Math.floor(Math.random() * 6) + 1;
            state[myRole + 'Roll'] = roll;
            
            if (state.hostRoll !== null && state.guestRoll !== null) {
                if (state.hostRoll > state.guestRoll) {
                    state.winner = 'host';
                    state.message = `${data.host} wint met ${state.hostRoll} tegen ${state.guestRoll}!`;
                } else if (state.guestRoll > state.hostRoll) {
                    state.winner = 'guest';
                    state.message = `${data.guest} wint met ${state.guestRoll} tegen ${state.hostRoll}!`;
                } else {
                    state.winner = 'DRAW';
                    state.message = 'Gelijkspel, gooi opnieuw voor de volgende ronde!';
                }
            } else {
                state.turn = opponentRole;
                state.message = `Wachten op ${data[opponentRole]} om te gooien.`;
            }

            await updateDoc(ref, { state: state });
        };

        window.diceNewRound = async (id) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;
            const data = snap.data();
            const state = data.state;

            state.hostRoll = null;
            state.guestRoll = null;
            state.winner = null;
            state.turn = state.turn === 'host' ? 'guest' : 'host'; 
            state.message = `${data[state.turn]} begint de nieuwe ronde. Gooi nu!`;

            await updateDoc(ref, { state: state });
        };

        function escape(s) {
            return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
    </script>
</body>
</html>
