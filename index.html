<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>De Oude Herberg</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script> <!-- Voor icons -->
    <style>
        /* --- SFEER & BASIS --- */
        body {
            font-family: 'Crimson Text', serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1, h2, h3, .tavern-font { font-family: 'Cinzel', serif; }

        .background-layer {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; object-fit: cover;
        }

        .main-scroll-container {
            width: 100%; height: 100%;
            overflow-y: auto;
            position: relative; z-index: 10;
            display: flex; flex-direction: column; align-items: center;
            padding: 20px;
        }

        /* --- PERKAMENT STIJLEN --- */
        .parchment-box {
            background-color: #f4e4bc;
            background-image: url("https://www.transparenttextures.com/patterns/aged-paper.png");
            box-shadow: 0 4px 20px rgba(0,0,0,0.6), inset 0 0 60px rgba(160, 82, 45, 0.2);
            border-radius: 4px;
            border: 2px solid #d7c496;
            position: relative;
            display: flex; flex-direction: column;
        }

        /* --- TITEL --- */
        .main-title {
            font-size: 4rem; color: #f4e4bc;
            text-shadow: 4px 4px 0px #3e2723, 0 0 20px rgba(0,0,0,0.8);
            margin: 1rem 0 2rem 0; font-weight: 700; text-align: center;
        }

        /* --- KNOPPEN --- */
        .tavern-btn {
            background: #5d4037; color: #f4e4bc;
            border: 2px solid #3e2723;
            transition: all 0.2s ease; cursor: pointer;
            text-decoration: none; display: flex; align-items: center; justify-content: center; gap: 8px;
            font-weight: bold;
        }
        .tavern-btn:hover {
            background: #795548; transform: scale(1.02); color: #fff;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        .tavern-btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }

        .btn-small { padding: 4px 12px; font-size: 0.9rem; }

        /* --- LAYOUT GRID (3 Kolommen) --- */
        .tavern-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            width: 100%; max-width: 1400px;
            align-items: start; /* Belangrijk zodat ze niet uitrekken */
        }

        /* --- CHAT (LINKS) --- */
        .chat-area { height: 500px; }
        .chat-messages {
            flex-grow: 1; overflow-y: auto; padding: 10px;
            background: rgba(255,255,255,0.4); border: 1px solid rgba(62,39,35,0.2);
            margin-bottom: 10px; border-radius: 4px;
        }
        .chat-input {
            background: rgba(255,255,255,0.7); border: 2px solid #5d4037;
            padding: 8px; border-radius: 4px; width: 100%;
        }

        /* --- MENU (MIDDEN) --- */
        .menu-area { padding: 2rem; }

        /* --- SPELLEN (RECHTS) --- */
        .games-area { height: 500px; }
        .games-list {
            flex-grow: 1; overflow-y: auto;
            background: rgba(62,39,35,0.05); padding: 10px;
            border-radius: 4px; margin-bottom: 10px;
        }
        .game-card {
            background: rgba(255,255,255,0.6); padding: 10px; margin-bottom: 8px;
            border: 1px dashed #5d4037; border-radius: 4px;
            display: flex; justify-content: space-between; align-items: center;
        }

        /* --- GAME OVERLAY (MODAL) --- */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: none; align-items: center; justify-content: center;
        }
        .modal-content {
            background: #f4e4bc; padding: 20px; border-radius: 8px;
            max-width: 600px; width: 95%; max-height: 90vh; overflow-y: auto;
            border: 4px solid #5d4037; text-align: center;
        }
        
        /* Kaartstijl */
        .card-button {
            width: 50px; height: 70px; 
            border: 1px solid #3e2723;
            border-radius: 4px;
            padding: 2px;
            text-align: center;
            line-height: 1.2;
            font-size: 1.2em;
        }
        .card-button:hover {
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .card-red { color: red; }
        .card-black { color: black; }


        /* Responsive */
        @media (max-width: 1000px) {
            .tavern-grid { grid-template-columns: 1fr; max-width: 600px; }
            .main-title { font-size: 2.5rem; }
            /* Volgorde voor mobiel: Menu eerst, dan Spellen, dan Chat */
            .area-menu { order: 1; }
            .area-games { order: 2; }
            .area-chat { order: 3; }
        }
    </style>
</head>
<body>

    <!-- BACKGROUND -->
    <img src="tavern.png" class="background-layer" alt="Tavern Background" onerror="this.style.background='#2c1810'">

    <div class="main-scroll-container">
        <h1 class="main-title">De Oude Herberg</h1>

        <!-- 3-KOLOMMEN GRID -->
        <div class="tavern-grid">

            <!-- KOLOM 1: CHAT (Links op desktop, onderaan op mobiel) -->
            <div class="parchment-box area-chat chat-area p-4">
                <h2 class="text-2xl tavern-font text-amber-900 mb-2 border-b border-amber-900/30">Gesprekken</h2>
                <div id="chat-messages" class="chat-messages text-left text-sm">
                    <div class="text-center italic text-amber-900/50 mt-4">Laden...</div>
                </div>
                <form id="chat-form" class="flex gap-2">
                    <input type="text" id="message-input" class="chat-input" placeholder="Zeg iets..." autocomplete="off">
                    <button type="submit" class="tavern-btn px-4 rounded">></button>
                </form>
                <div id="user-status" class="text-xs text-amber-900/60 mt-1 text-center">...</div>
            </div>

            <!-- KOLOM 2: MENU (Midden) -->
            <div class="parchment-box area-menu menu-area text-center">
                <h2 class="text-3xl tavern-font text-amber-900 mb-6 border-b-2 border-amber-900/20 pb-2">Menu</h2>
                <div class="space-y-4">
                    <a href="kaas.html" class="tavern-btn w-full py-4 text-xl"><span>üßÄ</span> Ik zie ik zie...</a>
                    <a href="jungle.html" class="tavern-btn w-full py-4 text-xl"><span>ü¶Å</span> Raad het dier</a>
                    <div class="py-2 text-amber-900/40 text-sm border-t border-dashed border-amber-900/20 mt-4">
                        Meer spellen in de maak...
                    </div>
                </div>
            </div>

            <!-- KOLOM 3: MULTIPLAYER SPELLEN (Rechts) -->
            <div class="parchment-box area-games games-area p-4">
                <h2 class="text-2xl tavern-font text-amber-900 mb-2 border-b border-amber-900/30 flex justify-between items-center">
                    <span>Herberg Spellen</span>
                    <span class="text-xs bg-amber-900 text-white px-2 py-0.5 rounded-full">Online</span>
                </h2>
                
                <!-- Knoppen om spellen te maken -->
                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button onclick="hostGame('tictactoe')" class="tavern-btn btn-small rounded py-2">‚ùå‚≠ï Boter Kaas</button>
                    <button onclick="hostGame('hangman')" class="tavern-btn btn-small rounded py-2">üî§ Galgje</button>
                    <!-- NIEUW: PESTEN -->
                    <button onclick="hostGame('pesten')" class="tavern-btn btn-small rounded py-2">üÉè Pesten</button>
                    <!-- NIEUW: DOBBELEN -->
                    <button onclick="hostGame('dice')" class="tavern-btn btn-small rounded py-2">üé≤ Dobbelen</button>
                </div>

                <h3 class="text-sm font-bold text-amber-800 mb-1 uppercase tracking-wide">Open Tafels:</h3>
                <div id="games-list" class="games-list">
                    <div class="text-center italic text-amber-900/50 mt-4">Geen open spellen.<br>Start er een!</div>
                </div>
            </div>

        </div>
    </div>

    <!-- GAME MODAL (Overlay) -->
    <div id="game-modal" class="modal-overlay">
        <div class="modal-content relative">
            <!-- AANGEPAST: userQuitGame roept nu de verwijder-logica aan -->
            <button onclick="userQuitGame()" class="absolute top-2 right-2 text-red-800 font-bold hover:text-red-600 border border-red-800 rounded px-2 bg-red-100">‚úñ Verlaten</button>
            <div id="game-stage">
                <!-- Dynamische Game Content komt hier -->
            </div>
        </div>
    </div>

    <!-- FIREBASE LOGIC -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, onSnapshot, query, serverTimestamp, orderBy, updateDoc, doc, deleteDoc, setDoc } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // 1. CONFIG
        const firebaseConfig = {
            apiKey: "AIzaSyBrJytboOjIzpTFHDLBrDlDrF8vIkJyqJ4",
            authDomain: "manonopeenrij.firebaseapp.com",
            projectId: "manonopeenrij",
            storageBucket: "manonopeenrij.firebasestorage.app",
            messagingSenderId: "575065794428",
            appId: "1:575065794428:web:78a68f77a426f7daf3e6f9",
            measurementId: "G-ERGHXY3LR7"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // Globals
        let currentUser = null;
        let myUsername = localStorage.getItem('tavern_username') || ('Gast ' + Math.floor(Math.random()*1000));
        localStorage.setItem('tavern_username', myUsername);
        let activeGameListener = null;
        let currentGameId = null;

        // Helper function (was missing before, caused bugs)
        window.isMyGame = function(g) {
            if(!currentUser) return false;
            return g.hostUid === currentUser.uid || g.guestUid === currentUser.uid;
        };
        
        // --- NEW HELPER: PESTEN DECK INITIALIZATION ---
        function initializeDeck() {
            const suits = ['‚ô•', '‚ô¶', '‚ô£', '‚ô†'];
            const ranks = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A', '2'];
            let deck = [];
            for (const suit of suits) {
                for (const rank of ranks) { deck.push(rank + suit); }
            }
            // Voeg twee jokers toe
            deck.push('Joker', 'Joker'); 
            
            // Schud de kaarten
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        // 2. AUTHENTICATION
        const initAuth = async () => {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    try { await signInWithCustomToken(auth, __initial_auth_token); return; } catch(e){}
                }
                await signInAnonymously(auth);
            } catch (err) { console.error("Auth failed", err); }
        };
        initAuth();

        onAuthStateChanged(auth, (user) => {
            if(user) {
                currentUser = user;
                document.getElementById('user-status').innerText = `Ingelogd als: ${myUsername}`;
                setupChat();
                setupGamesList();
            }
        });

        // 3. CHAT LOGIC
        function setupChat() {
            const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'chat'));
            onSnapshot(q, (snap) => {
                const msgs = [];
                snap.forEach(d => msgs.push({id: d.id, ...d.data()}));
                msgs.sort((a,b) => (a.timestamp?.seconds||0) - (b.timestamp?.seconds||0));
                
                const html = msgs.map(m => `
                    <div class="mb-1 border-b border-amber-900/10 pb-1">
                        <span class="font-bold text-amber-900">${m.author}:</span>
                        <span class="text-amber-800">${escape(m.text)}</span>
                    </div>`).join('');
                const el = document.getElementById('chat-messages');
                el.innerHTML = html || '<div class="text-center italic opacity-50">Stil...</div>';
                el.scrollTop = el.scrollHeight;
            });
        }

        document.getElementById('chat-form').addEventListener('submit', (e) => {
            e.preventDefault();
            const inp = document.getElementById('message-input');
            if(inp.value.trim() && currentUser) {
                addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'chat'), {
                    text: inp.value.trim(),
                    author: myUsername,
                    uid: currentUser.uid,
                    timestamp: serverTimestamp()
                });
                inp.value = '';
            }
        });

        // 4. MULTIPLAYER LOBBY LOGIC
        window.hostGame = async (type) => {
            if(!currentUser) return alert("Even geduld, verbinden...");
            
            // Maak een nieuwe game doc
            const gameData = {
                type: type,
                host: myUsername,
                hostUid: currentUser.uid,
                status: 'waiting', // waiting, playing, finished
                timestamp: serverTimestamp(),
                state: getInitialState(type)
            };

            const docRef = await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'games'), gameData);
            openGameUI(docRef.id, type, 'host');
        };

        function getInitialState(type) {
            if(type === 'tictactoe') return { board: Array(9).fill(''), turn: 'X', winner: null };
            if(type === 'hangman') return { word: '', guesses: [], mistakes: 0, setter: 'host', phase: 'setup' }; // phase: setup or guessing
            
            // NIEUW: PESTEN
            if(type === 'pesten') return { 
                turn: 'host', // host starts
                deck: [], // Wordt gevuld bij start
                hostHand: [], 
                guestHand: [], 
                discardPile: [],
                status: 'waiting_start' // waiting_start, playing, finished
            };
            
            // NIEUW: DOBBELEN
            if(type === 'dice') return { 
                turn: 'host', // host starts
                hostRoll: null, 
                guestRoll: null, 
                winner: null,
                message: 'Host begint.'
            };

            return {};
        }

        function setupGamesList() {
            const q = query(collection(db, 'artifacts', appId, 'public', 'data', 'games'));
            onSnapshot(q, (snap) => {
                const listEl = document.getElementById('games-list');
                const games = [];
                snap.forEach(d => games.push({id: d.id, ...d.data()}));
                
                // Filter: alleen wachtende spellen en recente actieve spellen tonen
                const activeGames = games.filter(g => g.status === 'waiting' || (g.status === 'playing' && window.isMyGame(g)));
                
                if(activeGames.length === 0) {
                    listEl.innerHTML = '<div class="text-center italic text-amber-900/50 mt-4">Geen open spellen.</div>';
                    return;
                }

                listEl.innerHTML = activeGames.map(g => {
                    const isMine = g.hostUid === currentUser.uid;
                    let icon;
                    if (g.type === 'tictactoe') icon = '‚ùå‚≠ï';
                    else if (g.type === 'hangman') icon = 'üî§';
                    else if (g.type === 'pesten') icon = 'üÉè';
                    else if (g.type === 'dice') icon = 'üé≤';
                    else icon = '‚ùì';

                    const gameName = g.type === 'tictactoe' ? 'Boter Kaas' : g.type === 'hangman' ? 'Galgje' : g.type === 'pesten' ? 'Pesten' : g.type === 'dice' ? 'Dobbelen' : 'Spel';
                    
                    const btnText = isMine ? 'Wachten...' : 'Meespelen';
                    const btnClass = isMine ? 'opacity-50 cursor-default' : 'hover:bg-amber-700';
                    const action = isMine ? '' : `onclick="joinGame('${g.id}')"`;
                    
                    // Als ik al in dit spel zit en het is playing, toon "Hervatten"
                    if(g.status === 'playing' && (g.hostUid === currentUser.uid || g.guestUid === currentUser.uid)) {
                        return `<div class="game-card">
                            <span>${icon} vs ${g.host}</span>
                            <button onclick="rejoinGame('${g.id}', '${g.type}')" class="tavern-btn btn-small rounded bg-green-700">Hervatten</button>
                        </div>`;
                    }

                    return `
                    <div class="game-card">
                        <div class="flex flex-col">
                            <span class="font-bold text-sm text-amber-900">${icon} ${gameName}</span>
                            <span class="text-xs text-amber-900/60">Host: ${g.host}</span>
                        </div>
                        <button ${action} class="tavern-btn btn-small rounded ${btnClass}">${btnText}</button>
                    </div>`;
                }).join('');
            });
        }

        window.joinGame = async (gameId) => {
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            await updateDoc(gameRef, {
                guestUid: currentUser.uid,
                guest: myUsername,
                status: 'playing'
            });
             openGameUI(gameId, null, 'guest'); 
        };

        window.rejoinGame = (id, type) => openGameUI(id, type, 'player');

        // 5. GAME PLAY UI
        
        // Functie voor als gebruiker zelf op 'Sluiten' klikt
        window.userQuitGame = async () => {
            if(currentGameId) {
                // Verwijder game uit DB zodat hij offline gaat voor iedereen
                try {
                    await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', currentGameId));
                } catch(e) { console.log("Game al weg of error", e); }
            }
            closeGameModal();
        };

        window.closeGameModal = () => {
            document.getElementById('game-modal').style.display = 'none';
            if(activeGameListener) activeGameListener(); // Unsubscribe
            activeGameListener = null;
            currentGameId = null;
        };

        function openGameUI(gameId, typeHint, role) {
            currentGameId = gameId;
            const modal = document.getElementById('game-modal');
            const stage = document.getElementById('game-stage');
            modal.style.display = 'flex';
            stage.innerHTML = '<div class="text-2xl animate-pulse">Spel laden...</div>';

            activeGameListener = onSnapshot(doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId), (docSnap) => {
                // Als document verwijderd is (door userQuitGame van iemand)
                if(!docSnap.exists()) {
                    stage.innerHTML = "<div class='text-red-800 font-bold text-xl'>Tafel is gesloten.</div>";
                    setTimeout(closeGameModal, 2000);
                    return;
                }
                const game = docSnap.data();
                renderGame(game, docSnap.id);
            });
        }

        function renderGame(game, id) {
            const stage = document.getElementById('game-stage');
            const amIHost = game.hostUid === currentUser.uid;
            
            // Header
            let gameTitle = game.type === 'tictactoe' ? 'Boter, Kaas & Eieren' : game.type === 'hangman' ? 'Galgje' : game.type === 'pesten' ? 'Pesten' : 'Dobbelen';
            let html = `<h2 class="text-3xl tavern-font mb-4 text-amber-900">${gameTitle}</h2>`;
            html += `<div class="mb-4 text-amber-800">Spelers: <b>${game.host}</b> vs <b>${game.guest || 'Wachten...'}</b></div>`;

            if(game.status === 'waiting') {
                html += `<div class="p-8 border-2 border-dashed border-amber-900/30 rounded bg-amber-50">
                    <p class="animate-pulse">Wachten op tegenstander...</p>
                    <p class="text-sm mt-2">De code ligt op tafel, wie durft?</p>
                </div>`;
                stage.innerHTML = html;
                return;
            }

            // --- TICTACTOE RENDER ---
            if(game.type === 'tictactoe') {
                const board = game.state.board;
                const mySymbol = amIHost ? 'X' : 'O';
                const isMyTurn = game.state.turn === mySymbol;
                const winner = game.state.winner;

                let statusText = isMyTurn ? "Jouw beurt!" : `Wachten op ${amIHost ? game.guest : game.host}...`;
                if(winner) statusText = winner === 'DRAW' ? "Gelijkspel!" : (winner === mySymbol ? "Je hebt gewonnen! üéâ" : "Helaas, verloren.");

                html += `<div class="text-xl font-bold mb-4 ${isMyTurn ? 'text-green-700' : 'text-amber-900'}">${statusText}</div>`;
                
                html += `<div class="grid grid-cols-3 gap-2 w-64 mx-auto mb-4">`;
                board.forEach((cell, idx) => {
                    html += `<div onclick="tttMove('${id}', ${idx}, '${mySymbol}', ${isMyTurn && !winner})" 
                        class="w-20 h-20 bg-amber-100 border-2 border-amber-900 flex items-center justify-center text-4xl cursor-pointer hover:bg-amber-200">
                        ${cell}
                    </div>`;
                });
                html += `</div>`;
                if(winner) html += `<button onclick="userQuitGame()" class="tavern-btn px-6 py-2 mx-auto mt-4 rounded">Sluit Spel</button>`;
            } 

            // --- HANGMAN RENDER ---
            else if(game.type === 'hangman') {
                const state = game.state;
                const isSetter = (state.setter === 'host' && amIHost) || (state.setter === 'guest' && !amIHost);
                
                if(state.phase === 'setup') {
                    if(isSetter) {
                        html += `<div class="flex flex-col gap-2">
                            <p>Kies een woord voor je tegenstander:</p>
                            <input type="text" id="hangman-word" class="p-2 border border-amber-900 rounded uppercase text-center" maxlength="10">
                            <button onclick="hangmanSetWord('${id}')" class="tavern-btn px-4 py-2 rounded">Bevestig Woord</button>
                        </div>`;
                    } else {
                        html += `<p class="animate-pulse">Tegenstander bedenkt een woord...</p>`;
                    }
                } else {
                    // Guessing Phase
                    const wordDisplay = state.word.split('').map(l => state.guesses.includes(l) ? l : '_').join(' ');
                    const won = !wordDisplay.includes('_');
                    const lost = state.mistakes >= 6;
                    
                    html += `<div class="text-4xl font-mono tracking-widest mb-6">${wordDisplay}</div>`;
                    html += `<div class="text-red-700 font-bold mb-4">Fouten: ${state.mistakes} / 6</div>`;

                    if(won || lost) {
                         const msg = won ? (isSetter ? "Ze hebben het geraden!" : "Je hebt gewonnen!") : (isSetter ? "Ze zijn opgehangen! Jij wint." : `Verloren! Het woord was ${state.word}`);
                         html += `<div class="text-2xl font-bold mb-4">${msg}</div>`;
                         html += `<button onclick="userQuitGame()" class="tavern-btn px-6 py-2 mx-auto rounded">Sluit Spel</button>`;
                    } else if (!isSetter) {
                        // Keyboard for guesser
                        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
                        html += `<div class="flex flex-wrap gap-1 justify-center max-w-md mx-auto">`;
                        alphabet.forEach(letter => {
                            const used = state.guesses.includes(letter);
                            html += `<button onclick="hangmanGuess('${id}', '${letter}')" 
                                ${used ? 'disabled' : ''} 
                                class="w-8 h-8 border border-amber-900 rounded ${used ? 'bg-amber-900/20' : 'bg-amber-100 hover:bg-white'}">
                                ${letter}
                            </button>`;
                        });
                        html += `</div>`;
                    } else {
                        html += `<p>Je tegenstander is aan het raden...</p>`;
                    }
                }
            }
            
            // --- NIEUW: PESTEN RENDER ---
            else if(game.type === 'pesten') {
                const state = game.state;
                const myRole = amIHost ? 'host' : 'guest';
                const opponentRole = amIHost ? 'guest' : 'host';
                const isMyTurn = state.turn === myRole;
                const myHand = state[myRole + 'Hand'];
                const opponentHandSize = state[opponentRole + 'Hand'] ? state[opponentRole + 'Hand'].length : 0;
                const topCard = state.discardPile.length > 0 ? state.discardPile[state.discardPile.length - 1] : 'Geen';
                const topRank = topCard.replace(/[‚ô•‚ô¶‚ô£‚ô†]/, '');
                const topSuit = topCard.slice(-1);

                if (state.status === 'waiting_start') {
                    html += `<p class="mb-4">Wachten op een tegenstander om te starten...</p>`;
                    if (amIHost) {
                        html += `<button onclick="pestenStartGame('${id}')" ${game.guest ? '' : 'disabled'} class="tavern-btn px-6 py-2 rounded mt-2">Start Spel & Deel Kaarten</button>`;
                    } else {
                        html += `<p class="animate-pulse text-sm mt-2">Wachten op de host (${game.host}) om te starten.</p>`;
                    }
                } else if (state.status === 'finished') {
                    html += `<div class="text-2xl font-bold text-red-700 mt-4">${state.winner === myRole ? "Je hebt gewonnen!" : `Je hebt verloren. Winnaar: ${game[state.winner]}`}</div>`;
                    html += `<button onclick="userQuitGame()" class="tavern-btn px-6 py-2 mx-auto mt-4 rounded">Sluit Spel</button>`;
                } else {
                    let statusText = isMyTurn ? "Jouw beurt! Speel of pak een kaart." : `Wachten op ${game[state.turn]}...`;
                    
                    html += `<div class="text-xl font-bold mb-4 ${isMyTurn ? 'text-green-700' : 'text-amber-900'}">${statusText}</div>`;
                    html += `<div class="flex justify-around items-center mb-4 text-center border-b pb-4 border-amber-900/20">
                        <div><span class="text-sm text-amber-800">${game[opponentRole]}</span><br>üÉè x ${opponentHandSize}</div>
                        <div>
                            <span class="text-xs text-amber-800">Bovenste Kaart:</span><br>
                            <span class="text-3xl font-bold ${topSuit === '‚ô•' || topSuit === '‚ô¶' ? 'card-red' : 'card-black'}">${topCard}</span>
                        </div>
                        <div><span class="text-sm text-amber-800">Deck:</span><br>üì¶ x ${state.deck.length}</div>
                    </div>`;
                    
                    // My Hand
                    html += `<h3 class="font-bold mb-2">Jouw Kaarten:</h3>`;
                    html += `<div class="flex flex-wrap justify-center gap-2 mb-4">`;
                    myHand.forEach((card, index) => {
                         const cardRank = card.replace(/[‚ô•‚ô¶‚ô£‚ô†]/, '');
                         const cardSuit = card.slice(-1);
                         
                         // Simplified Playability Check
                         const canPlay = cardRank === topRank || cardSuit === topSuit || cardRank === 'Joker' || cardRank === '2';
                         
                         const colorClass = cardSuit === '‚ô•' || cardSuit === '‚ô¶' ? 'card-red' : 'card-black';
                         const enabledClass = isMyTurn && canPlay ? 'bg-white hover:bg-green-100 cursor-pointer' : 'bg-gray-300 opacity-70 cursor-not-allowed';

                         html += `<button 
                            onclick="pestenPlayCard('${id}', '${card}', ${index})" 
                            ${!(isMyTurn && canPlay) ? 'disabled' : ''}
                            class="card-button ${colorClass} ${enabledClass}">
                            ${card}
                        </button>`;
                    });
                    html += `</div>`;
                    
                    // Draw Button
                    html += `<button onclick="pestenDrawCard('${id}')" ${!isMyTurn ? 'disabled' : ''} class="tavern-btn px-6 py-2 rounded mt-2">
                        ${isMyTurn ? `Pak een kaart (Deck: ${state.deck.length})` : 'Wachten...'}
                    </button>`;
                }
            }

            // --- NIEUW: DOBBELEN RENDER ---
            else if(game.type === 'dice') {
                const state = game.state;
                const myRole = amIHost ? 'host' : 'guest';
                const isMyTurn = state.turn === myRole;
                
                let statusText = state.message;
                if (!state.winner && !state.hostRoll && !state.guestRoll) {
                    statusText = isMyTurn ? "Tijd om te dobbelen!" : `Wachten op ${game[state.turn]} om te gooien...`;
                }

                html += `<div class="text-xl font-bold mb-4 text-amber-900">${statusText}</div>`;
                
                // Dice Display
                html += `<div class="flex justify-around items-center my-6">
                    <div class="text-center">
                        <h3 class="font-bold text-amber-800">${game.host}</h3>
                        <div class="text-6xl p-4 border border-amber-900/50 rounded inline-block bg-amber-100">${state.hostRoll !== null ? state.hostRoll : '?'}</div>
                    </div>
                    <div class="text-center">
                        <h3 class="font-bold text-amber-800">${game.guest || 'Tegenstander'}</h3>
                        <div class="text-6xl p-4 border border-amber-900/50 rounded inline-block bg-amber-100">${state.guestRoll !== null ? state.guestRoll : '?'}</div>
                    </div>
                </div>`;

                if (state.winner) {
                    html += `<button onclick="diceNewRound('${id}')" class="tavern-btn px-6 py-2 mx-auto mt-4 rounded">Nieuwe Ronde</button>`;
                    html += `<button onclick="userQuitGame()" class="tavern-btn px-6 py-2 mx-auto mt-4 rounded bg-red-700">Sluit Spel</button>`;
                } else if (isMyTurn) {
                    html += `<button onclick="diceRoll('${id}')" class="tavern-btn px-8 py-3 rounded text-xl animate-pulse">Gooi de Dobbelsteen! üé≤</button>`;
                } else {
                    html += `<p class="italic text-sm">Wachten...</p>`;
                }
            }

            stage.innerHTML = html;
        }

        // --- GAME ACTIONS ---
        
        // Tic Tac Toe Move
        window.tttMove = async (gameId, index, symbol, allowed) => {
            if(!allowed) return;
            // Note: Handled in separate script block due to module/scope, see below
        };
        
        // Hangman Actions
        window.hangmanSetWord = async (id) => {
            const word = document.getElementById('hangman-word').value.toUpperCase().trim();
            if(word.length < 2) return alert("Te kort!");
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            await updateDoc(gameRef, {
                'state.word': word,
                'state.phase': 'guessing'
            });
        };

        window.hangmanGuess = async (id, letter) => {
             // Handled in separate script block
        };
        
        window.deleteGame = async (id) => {
             await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'games', id));
             closeGameModal();
        };

        function escape(s) {
            return s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
    </script>
    
    <!-- EXTRA SCRIPT VOOR GAME LOGIC MET GETDOC (Import fix) -->
    <script type="module">
        import { getFirestore, doc, getDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js'; // <-- TOEGEVOEGD
        
        const firebaseConfig = {
            apiKey: "AIzaSyBrJytboOjIzpTFHDLBrDlDrF8vIkJyqJ4",
            authDomain: "manonopeenrij.firebaseapp.com",
            projectId: "manonopeenrij",
            storageBucket: "manonopeenrij.firebasestorage.app",
            messagingSenderId: "575065794428",
            appId: "1:575065794428:web:78a68f77a426f7daf3e6f9",
            measurementId: "G-ERGHXY3LR7"
        };
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        const auth = getAuth(app); // <-- TOEGEVOEGD
        
        // Pesten helper om kaart te verwijderen
        function removeCard(hand, cardToRemove) {
            const index = hand.indexOf(cardToRemove);
            if (index > -1) {
                hand.splice(index, 1);
                return true;
            }
            return false;
        }

        // TTT LOGIC
        window.tttMove = async (id, idx, symbol, allowed) => {
            if(!allowed) return;
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if(!snap.exists()) return;
            const data = snap.data();
            const state = data.state;
            
            if(state.board[idx] !== '') return; // Already taken
            
            state.board[idx] = symbol;
            state.turn = symbol === 'X' ? 'O' : 'X';
            
            // Check win
            const wins = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
            if(wins.some(c => state.board[c[0]] && state.board[c[0]] === state.board[c[1]] && state.board[c[0]] === state.board[c[2]])) {
                state.winner = symbol;
            } else if(!state.board.includes('')) {
                state.winner = 'DRAW';
            }
            
            await updateDoc(ref, { state: state });
        };

        // HANGMAN LOGIC
        window.hangmanGuess = async (id, letter) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if(!snap.exists()) return;
            const data = snap.data();
            const state = data.state;

            if(state.guesses.includes(letter)) return;
            state.guesses.push(letter);
            
            if(!state.word.includes(letter)) {
                state.mistakes++;
            }
            
            await updateDoc(ref, { state: state });
        };
        
        // NIEUW: PESTEN LOGIC
        window.pestenStartGame = async (id) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists() || !snap.data().guest) return;
            let data = snap.data();
            let state = data.state;
            
            if (state.status !== 'waiting_start') return;

            // Roep de globale initializeDeck aan
            const fullDeck = window.initializeDeck ? window.initializeDeck() : []; 
            if (fullDeck.length < 15) { // Minimaal 15 kaarten nodig
                console.error("Deck te klein of niet geladen.");
                return;
            }
            state.deck = fullDeck;
            state.hostHand = state.deck.splice(0, 7);
            state.guestHand = state.deck.splice(0, 7);

            // Speel eerste kaart
            let firstCard = state.deck.splice(0, 1)[0];
            state.discardPile.push(firstCard);
            state.status = 'playing';

            await updateDoc(ref, { state: state });
        };

        window.pestenPlayCard = async (id, card, index) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;
            const data = snap.data();
            const state = data.state;
            
            const myRole = data.hostUid === auth.currentUser.uid ? 'host' : 'guest';
            const opponentRole = myRole === 'host' ? 'guest' : 'host';

            if (state.turn !== myRole || state.status !== 'playing') return;

            const topCard = state.discardPile[state.discardPile.length - 1];
            const cardRank = card.replace(/[‚ô•‚ô¶‚ô£‚ô†]/, '');
            const topRank = topCard.replace(/[‚ô•‚ô¶‚ô£‚ô†]/, '');
            const cardSuit = card.slice(-1);
            const topSuit = topCard.slice(-1);

            // Simplified Playability Check (Match Rank or Suit, or Special Card)
            const canPlay = cardRank === topRank || cardSuit === topSuit || cardRank === 'Joker' || cardRank === '2';

            if (!canPlay) { return; } // Should not happen if button is disabled correctly

            // Move card from hand to discard pile
            state.discardPile.push(card);
            removeCard(state[myRole + 'Hand'], card);
            
            // Check for win
            if (state[myRole + 'Hand'].length === 0) {
                state.winner = myRole;
                state.status = 'finished';
            } else {
                // Change turn (simplified)
                state.turn = opponentRole;
            }

            await updateDoc(ref, { state: state });
        };

        window.pestenDrawCard = async (id) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;
            const data = snap.data();
            const state = data.state;
            
            const myRole = data.hostUid === auth.currentUser.uid ? 'host' : 'guest';
            const opponentRole = myRole === 'host' ? 'guest' : 'host';

            if (state.turn !== myRole || state.status !== 'playing') return;
            if (state.deck.length === 0) return;

            const drawnCard = state.deck.splice(0, 1)[0];
            state[myRole + 'Hand'].push(drawnCard);

            // Turn change is MANDATORY after drawing
            state.turn = opponentRole;

            await updateDoc(ref, { state: state });
        };

        // NIEUW: DICE LOGIC
        window.diceRoll = async (id) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;
            const data = snap.data();
            const state = data.state;
            
            const myRole = data.hostUid === auth.currentUser.uid ? 'host' : 'guest';
            const opponentRole = myRole === 'host' ? 'guest' : 'host';
            
            if (state.turn !== myRole || state.winner) return;

            const roll = Math.floor(Math.random() * 6) + 1;
            state[myRole + 'Roll'] = roll;
            
            // Check for winner if both have rolled
            if (state.hostRoll !== null && state.guestRoll !== null) {
                if (state.hostRoll > state.guestRoll) {
                    state.winner = 'host';
                    state.message = `${data.host} wint met ${state.hostRoll} tegen ${state.guestRoll}!`;
                } else if (state.guestRoll > state.hostRoll) {
                    state.winner = 'guest';
                    state.message = `${data.guest} wint met ${state.guestRoll} tegen ${state.hostRoll}!`;
                } else {
                    state.winner = 'DRAW';
                    state.message = 'Gelijkspel, gooi opnieuw voor de volgende ronde!';
                }
            } else {
                // Change turn
                state.turn = opponentRole;
                state.message = `Wachten op ${data[opponentRole]} om te gooien.`;
            }

            await updateDoc(ref, { state: state });
        };

        window.diceNewRound = async (id) => {
            const ref = doc(db, 'artifacts', appId, 'public', 'data', 'games', id);
            const snap = await getDoc(ref);
            if (!snap.exists()) return;
            const data = snap.data();
            const state = data.state;

            // Reset rolls and winner, keeping current turn or switching turn for next game
            state.hostRoll = null;
            state.guestRoll = null;
            state.winner = null;
            state.turn = state.turn === 'host' ? 'guest' : 'host'; // Switch who starts the next round
            state.message = `${data[state.turn]} begint de nieuwe ronde. Gooi nu!`;

            await updateDoc(ref, { state: state });
        };
    </script>
</body>
</html>
